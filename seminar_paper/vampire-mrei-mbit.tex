\documentclass{article}

\include{Seminar}

\usepackage{enumerate}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{color}
\usepackage{enumitem}

\setlist[itemize,2]{label=$\circ$} %nur blubbel für aufzählung zweiter-stufe
\setlist[itemize]{itemsep=1pt} % geringerer abstand zwischen items

\makeatletter %definition of classes for highlighting
\lst@InstallKeywords k{tfftypes}{tfftypesstyle}\slshape{tfftypesstyle}{}ld
\lst@InstallKeywords k{tfffunctions}{tfffunctionsstyle}\slshape{tfffunctionsstyle}{}ld
\lst@InstallKeywords k{formulatypes}{formulatypesstyle}\slshape{formulatypesstyle}{}ld
\lst@InstallKeywords k{tptpkeywords}{tptpkeywordsstyle}\slshape{tptpkeywordsstyle}{}ld
\lst@InstallKeywords k{roles}{rolesstyle}\slshape{rolesstyle}{}ld
\makeatother

% Define Language for highlighting
\lstdefinelanguage{tptp}
{
	% list of keywords
	tfftypes={
		\$tType,
		\$i,
		\$o,
		\$int,
		\$rat,
		\$real,
		\$array1,
		\$array2,
	},
	formulatypes={
		fof,
		tff,
		cnf,
		tpi,
		thf,
		bnf,
	},
	tfffunctions={
		\$sum,		\$product,
		\$difference,
		\$uminus,
		\$torat,
		\$toreal,
		\$less,
		\$lesseq,
		\$greater,
		\$greatereq,
	},
	tptpkeywords={
		\$ite\_f,
		\$ite\_t,
		\$let\_tt,
		\$let\_tf,
		\$let\_ft,
		\$let\_ff,
	},
	roles={
		axiom,
		hypothesis,
		conjecture,
		type,
	},	
	keywords={ %add more for highlighting of in formula defined functions
		member, 
		sum,
	},
	sensitive=true, % keywords are case-sensitive
	morecomment=[l]{\%}, % l is for line comment
	morecomment=[s]{/*}{*/}, % s is for start and end delimiter
	%morestring=[b]" % defines that strings are enclosed in double quotes
}

% Define Colors for highlighting
\usepackage{color}
\definecolor{blue}{RGB}{0,0,205}
\definecolor{lightblue}{RGB}{99,184,255}
\definecolor{green}{RGB}{0,139,0}
\definecolor{purple}{RGB}{139,0,139}
\definecolor{red}{RGB}{205,38,38}
\definecolor{orange}{RGB}{205,102,0}
\definecolor{brown}{RGB}{139,69,19}
\definecolor{grey}{RGB}{160,160,160}

% Set Language for highlighing
\lstset{
	language={tptp},
	basicstyle=\small\ttfamily, % Global Code Style
	captionpos=b, % Position of the Caption (t for top, b for bottom)
	extendedchars=true, % Allows 256 instead of 128 ASCII characters
	tabsize=2, % number of spaces indented when discovering a tab 
	columns=fixed, % make all characters equal width
	keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
	showstringspaces=false, % lets spaces in strings appear as real spaces
	breaklines=true, % wrap lines if they don't fit
	frame=trbl, % draw a frame at the top, right, left and bottom of the listing
	frameround=tttt, % make the frame round at all four corners
	numbers=left, % show line numbers at the left
	numberstyle=\tiny\ttfamily, % style of the line numbers
	commentstyle=\color{grey}, % style of comments
	%stringstyle=\color{missing_color}, % style of strings
	tfftypesstyle=\color{lightblue}, % style of tff-types (e.g. $int)
	formulatypesstyle=\color{purple}, % style of foruma-types (e.g. fof)
	tfffunctionsstyle=\color{orange}, % style of tff-functions (e.g. $sum)
	tptpkeywordsstyle=\color{green}, % style of tptp-keywords (e.g. $ite_f)
	rolesstyle=\color{brown}, % style of roles (e.g. axiom)
	keywordstyle=\color{blue}, %style of general keywords like introduced functions (e.g. member)
}

\author{
	Maximilian Reinhart\\
	Martin Bittermann
}

\title{VAMPIRE: Grundlagen und Anwendung}

% Generate PDF hyperlinks when referencing sections and stuff. 
\usepackage{hyperref}

% Frakturzeichen -  Double-stroke symbols
\usepackage{dsfont}

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
	%Notes:
	%Klaren Bezug auf [1] herausstellen.
	%Grafiken nicht am Anfang des paper, eher am anfang von kapitel 2.
	\texttt{ARBEITSFASSUNG}\\
	\\
	Dieser Artikel verschafft zunächst ein grundlegendes Verständnis über den automatischen Theorembeweiser VAMPIRE und
	stellt den Bezug zu ~\cite{cav2013} her. \\
	Es wird eine Einführung in die generelle Benutzung der Software und die verwendete Problembeschreibungssprache, TPTP, gegeben, 
	die Funktionsweise und einige ausgewählte Algorithmen erklärt und
	die Ausgabe von VAMPIRE sowohl analysiert als auch grafisch dargestellt.
	Es werden Parallelen zu anderen Theorembeweisern aufgezeigt, VAMPIRE mit diesen Verglichen 
	und zum Schluss wird mit Hinblick auf mögliche Anwendungsbereiche ein Fazit und ein Ausblick gegeben.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Einleitung}
\label{sec:introduction}

Automatische Theorembeweiser (ATP) versuchen ohne Benutzerinteraktion Aussagen über gegebene Formeln durch Anwendung von Regeln und Axiomen, die ihnen vorliegen, zu beweisen.
Hierfür wird das Problem von Hand in eine formale Struktur gebracht, die der Beweiser verarbeiten kann.
Diese Formalisierung stellt auch für triviale Probleme eine gefährliche Fehlerquelle dar. 
Nichtsdestotrotz ist für komplexe Probleme das Formalisieren einfacher als das Beweisen per Hand und nach korrekter Formalisierung liefert der ATP mit etwas Glück, nach vertretbarer Zeit,
einen formal korrekten Beweis. Scheitert der Beweis an Zeit- oder Speicherlimits, kann eine
Umformulierung oder Aufteilung in kleinere Probleme helfen, dies bringt eine interaktive
Komponente in das automatische Theorembeweisen.
Anwendung finden ATP in vielerlei Gebieten, unter anderem Hardwaredesign und -verifikation, Softwareverifikation, wissensbasierte Systeme und klassische mathematische Problemstellungen.
Der Vorteil von ATP liegt in diesen Gebieten in der Fähigkeit, Probleme zu bearbeiten, 
die für eine manuelle Beweisführung (teils um Größenordnungen) zu umfangreich sind.
VAMPIRE ist ein ATP für Logik erster Stufe (Prädikatenlogik) mit Gleichheit. Die erste Implementierung stammt von 1993, im Verlauf wurde die Software mehrfach um- und neugeschrieben.
Die Software umfasst heute etwa 152,000 SLOC in C++ und wurde hauptsächlich von Andrei Voronkov und Kry{\v{s}}tof Hoder an der University of Manchester entwickelt.
Neuere Entwicklungen und Ideen stammen vemehrt von Laura Kov{\'a}cs und Ioan Dragan, der Arbeiten am SAT-Beweiser und der Bound Propagation übernommen hat.
Derzeit wird an der vierten Version von VAMPIRE gearbeitet.
VAMPIRE hat dreißig Preise gewonnen und seit 1999 in der Weltmeisterschaft für automatische Theorembeweiser (CASC) jedes Mal mindestens in einer Kategorie gewonnen.
Insgesamt zwölf Mal hat er bei der CASC die Kategorie für Logik erster Stufe gewonnen und elf Mal für CNF/MIX. ~\cite{vampirehp} \\ Daher gilt VAMPIRE allgemein hin als sehr schnell.
Dank seiner Multiplattform- und Multicore-Unterstützung soll er auf allen gängigen Betriebssystemen, wie Linux, Windows und Mac eingesetzt werden können und mehrere Beweisversuche gleichzeitig bearbeiten können.
Wir vermögen zu bestätigen, dass die uns vorliegende Version 3.0 auf Windows 7, 64-bit funktioniert, lediglich mehrere Kerne wurden nicht benutzt und somit nicht mehrere Beweisversuche parallel unternommen.
Vampire löst Probleme über die ihm über die Kommandozeile mitgegebene Strategie, die über den Mode-Befehl eingestellt werden kann und besitzt eine auf einzigartige limited resource strategy, die für kurze Zeitlimits sehr effizient sein soll. Mit Vampire ist es, neben seiner Funktion als ATP, auch möglich ein Expertensystem zu betreiben, das auf Grund von gegebenen Aussagen Antworten aus einer Wissenssammlung geben kann, ebenso ist VAMPIRE zur Programmverifikation für C-Programme mit Schleifen geeignet. 
Leider steht Vampire entgegen der Aussage in ~\cite{cav2013} nicht unter einer liberalen Lizenz, sondern unter einer nicht-freien, proprietären Lizenz, die in ~\cite{vampirehp} einzusehen ist.
Als Primärquelle für diese Arbeit dient der Artikel \textit{First-Order Theorem Proving and VAMPIRE}~\cite{cav2013}.
Weitere Informationen stammen aus \textit{Interpolation and Symbol Elimination in Vampire}~\cite{hoder2010} 
und \textit{Finding Loop Invariants for Programs over Arrays Using a Theorem Prover}~\cite{kovacs2009finding}.
Die Arbeit ist praxisorientiert und kann als Einstiegstutorial verwendet werden.
In dieser \hyperref[sec:introduction]{Einleitung} wurden Grundlagen über automatische Theorembeweiser vermittelt, die einen schnellen Einstieg in das Thema ermöglichen.\\
Als Vorbereitung für die Benutzung von VAMPIRE wird auf die Syntax und Semantik der von VAMPIRE verwendeten \hyperref[sec:input]{Problembeschreibungssprache TPTP} eingegangen. Es werden Hilfestellungen zur Formulierung von Axiomen und Problemen gegeben, sowie auf Erweiterungen der Sprache durch VAMPIRE eingegangen.
Mit dieser Grundlage wird die \hyperref[sec:invocation]{Benutzung von Vampire}, insbesondere der Aufruf des Programms und die vielen einstellbaren Optionen behandelt.\\
Anschließend wird die \hyperref[sec:mechanics]{Funktionsweise} von VAMPIRE in den Grundzügen erklärt. Das zugrunde liegende Beweisverfahren wird erläutert und ausgewählte Algorithmen erklärt.\\
Schließlich folgt eine Erklärung der \hyperref[sec:output]{Beweisausgabe}. Es wird versucht, mit VAMPIRE erzeugte Beweise nachzuvollziehen.\\
Ein kurzes \hyperref[sec:conclusion]{Schlusswort} schließt die Arbeit ab.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TPTP Eingabe}
\label{sec:input}

TPTP ist die Sprache, in der Probleme und Axiome geschrieben sein müssen, damit Vampire sie bearbeiten kann. TPTP besitzt Ähnlichkeit zu Prolog und wird von vielen heutigen Therembeweisern für Logik 1. Stufe unterstützt. \cite[S. 4]{cav2013}. Die Sprache dient als Grundlage für die gleichnamige \textit{Thousands of Problems for Theorem Provers (TPTP)} Bibliothek. Die Sprache unterstützt folgende Formeltypen:
\begin{itemize}
	\item First order formula (FOF)
	\item Typed first order formula (TFF)
	\item Clause normal form (CNF)
	\item TPTP Process Instruction Language  (TPI)
	\item Typed higher order form (THF)
\end{itemize}
Vampire unterstützt hieraus FOF, TFF und CNF.

\subsection{Syntax}
\label{subsec:syntax}
\begin{wraptable}{r}{4cm}
\begin{tabular}{|c|c|}
	\hline TPTP & Bedeutung \\ 
	\hline ?[X] & $\exists$X \\
	\hline ![X] & $\forall$X \\
	\hline = & = \\
	\hline != & $\neq$ \\
	\hline $\sim$ & $\lnot$ \\
	\hline / & $\lor$ \\
	\hline \& & $\land$ \\
	\hline => & $\Rightarrow$ \\
	\hline <=> & $\leftrightarrow$ \\
	\hline Y & Variable \\
	\hline y & Literal \\
	\hline f(x, A, B) & Prädikat \\
	\hline \% \dots & Kommentar \\
	\hline
\end{tabular} 
\end{wraptable}
Die Syntax von TPTP ist wie folgt definiert:\\
Eine Formel in TPTP beginnt stets mit der Information über ihren Typ. Hierbei können zum Beispiel $fof(\dots)$, $tff(\dots)$, $cnf(\dots)$ und einige mehr verwendet werden.
Innerhalb der Klammern werden drei Bereiche unterschieden, die jeweils mit einem Komma voneinander getrennt sind. 
Zuerst kommt der Name der Formel, welcher lediglich zur besseren Übersicht im späteren Beweis verwendet wird und ansonsten weder benutzt noch eindeutig sein muss,
dann die Rolle, die diese Formel einnimmt, hierbei kann es sich zum Beispiel um ein Axiom (axiom), eine Hypothese (hypothesis) oder auch eine Behauptung (conjecture) handeln.
Eine Rolle ist eine wichtige Voraussetzung für den Beweiser, denn hierdurch erfährt er, welche Grundvoraussetzungen und Annahmen getroffen wurden, die er als richtig behandeln kann um die gestellte Behauptung zu beweisen.
Letztendlich steht die Formel in der Anfangs gewählten Syntax, die der Beweiser behandeln kann.
\subsection{First order formula (FOF)}
\label{subsec:tptpfof}
Wollen wir nun die Formel 
\[\forall X,A : X \in \bigcup A \Leftrightarrow \exists Y : Y \in A \land X \in Y,\]
die für einen späteren Beweis als Axiom dienen soll, in TPTP umwandeln, 
so bedarf es der Definition der Operationen, die im formalen Aufschrieb einfach benutzt werden können, 
die in der Syntax von TPTP jedoch nicht vorhanden sind.
Hierzu gehört neben $\in$ auch  $\bigcup$. 
Nun verhält es sich derart, dass wenn wir die fehlenden Operationen als Prädikate definieren, 
wir nicht zwingend eines zur Zeit in einem Axiom definieren, sondern manchmal allein durch die Definition und Nutzung eines Prädikates der Verwendungszweck erschlossen werden kann.
Ein Prädikat wird in VAMPIRE definiert indem es benutzt wird und im Verlauf des Beweises sucht VAMPIRE nach Möglichkeiten aus den gegebenen Axiomen und Hypothesen Schlüsse und Herleitungen zu ziehen.
So wandelt sich die obige Formel in TPTP um in 
\begin{lstlisting}[language=tptp]
! [X,A] : (member(X,sum(A))
	<=> ? [Y] : (member(Y,A) & member(X,Y)).
\end{lstlisting}
$\in$ wurde durch $member(\dots)$ ersetzt, $\bigcup$ durch $sum(\dots)$.
Legen wir jetzt fest, dass es sich um Logik erster Stufe handelt ($fof(\dots)$), dass die Definition, die Namensgeber wird, da wir diese vorwiegend tätigen, die große Vereinigung über eine Menge ist ($sum$) und, dass es sich um ein $Axiom$ handelt,
entsteht in Verbindung mit unser umgewandelten TPTP-Formel folgende fertige TPTP-Aussage:
\begin{lstlisting}[language=tptp]
fof(sum, axiom, (	
	! [X,A] : (member(X, sum(A)) 
		<=> ? [Y] : (member(Y, A) & member(X, Y))))).
\end{lstlisting}
Eine solcher Block wird immer mit einem Punkt abgeschlossen, dieser markiert das Ende.
Zusätzlich mit diesem und anderen Axiomen, die es nutzen, definiert sich das $member$ Prädikat automatisch.
Über den Befehl $include(\dots)$ können Dateien, wie zum Beispiel eine Datei mit vorgefertigten Axiomen, von extern in die TPTP-Problem-Datei eingebunden werden.

\subsection{Typed first order formula (TFF)}
\label{subsec:tptptff}

In $tff(\dots)$ können getypte Variablen verwendet werden. Um eine Variable zu typen muss ihr bei ihrer Verwendung im Quantor mit einem Doppelpunkt ein Typenausdruck (sort) folgen.
Typenausdrücke sind \begin{itemize}
	\item \$i: individuell. Standard-Typ, wenn nichts angegeben
	\item \$o: Boolesch
	\item \$int: Integer
	\item \$rat: Rational
	\item \$real: Reell
	\item \$array1: Integer-Array
	\item \$array2: Array von Integer-Array
\end{itemize}
wobei die letzten beiden spezifisch von VAMPIRE definiert sind und nicht im TPTP-Standard verankert sind.
Eigene Typenausdrücke können durch ein ähnliches Schema definiert werden wie ein generelles $fof$-Formular:
\begin{lstlisting}[language=tptp]
tff(name, type, typ_name: $tType).
\end{lstlisting}
Ein Name kann wie bekannt frei gewählt werden und das Wort $type$ ist die Deklaration, dass es sich um eine Typendefinition handelt, wobei dieses Wort sowohl uneindeutig als auch redundant ist.
Zuletzt wird der $typ\_name$, der wieder frei gewählt werden kann, als neuer Typ definiert. Beispiel:
\begin{lstlisting}[language=tptp]
tff(a_has_type_own,type,a : own).
tff(f_has_type_own,type,f : own * own > own).
\end{lstlisting}
Letzteres zeigt die Typdefinition einer Funktion f, die zwei Argumente übernimmt, deren Typ $own$ ist, und deren Ausgabe wieder des Typs $own$ ist.\\
\\
Um besser mit ganzen, rellen oder rationalen Zahlen arbeiten zu können, beinhaltet Vampire folgende, im TPTP-Standard definierten Funktionen:
\begin{itemize}
	\item $\$sum$: Addition $(x + y)$
	\item $\$product$: Multiplication $(x * y)$
	\item $\$difference$: Differnenz $(x - y)$
	\item $\$uminus$: einstelliges Minus $(-x)$
	\item $\$to rat$: Konvertierung zu rationalen Zahlen
	\item $\$to real$: Konvertierung zu reellen Zahlen
	\item $\$less$: kleiner als $(x < y)$
	\item $\$lesseq$: kleiner-gleich $(x \leq y)$
	\item $\$greater$: größer als $(x > y)$
	\item $\$greatereq$: größer-gleich $(x \geq y)$ 
\end{itemize}
Beispiel: $(x + y) \geq 0$ mit x, y aus den ganzen Zahlen
\begin{lstlisting}[language=tptp]
tff(example,conjecture, 
	? [X:$int,Y:$int] : $greatereq($sum(X,Y),0)).\end{lstlisting}

\subsection{If-Then-Else}
\label{subsec:tptpitef}

Vereinfachend für die Programmverifikation kann beim umschreiben von Programmen nach TPTP das if-then-else-Konstrukt $ \$ite\_f $ für Formeln und $\$ite\_t$ für Terme benutzt werden.
\begin{lstlisting}[language=tptp]
$ite_f(Bedingung, Dann, Sonst) % aequivalent fuer $ite_t
\end{lstlisting}
\begin{lstlisting}[language=tptp]
tff(c1,axiom,((($ite_f(p & q, ~p | ~q, p & q)).
tff(c2,axiom,($ite_t(p,a,b) != (a & p)).
\end{lstlisting}
~\cite{hoder2011slides}
\subsection{Let...in}
\label{subsec:tptpletin}

Gleichsam kann das $let\dots in$-Konstrukt für für Therme $\$let\_tt$, für Formeln $\$let\_ff$, und zwischen Thermen und Formeln, bzw. Formeln und Thermen $\$let\_tf$ und $\$let\_ft$ verwendet werden.
\begin{lstlisting}[language=tptp]
tff(c1,axiom,
	$let_tt(f(X), g(X), f(a)) != g(a)).
tff(c2,axiom,
	$let_ff}(p(X), q(X) | r(X), p(c)) & ~q(c) & ~r(c)).
tff(c3,axiom,
	$let_tf(f(X), g(X), p(f(X))) & ~p(g(X))).
tff(c4,axiom,
$let_ft(p(X), q, $ite_t(p(a), a, b)) != $ite_t(q, a, b)).
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vergleich}
\label{subsec:tptpcomp}
Das Programmierparadigma von TPTP ähnelt dem der Logik-Programmiersprache Prolog.
Prädikate werden durch Constraints, die in einer oder mehreren Formeln ausgedrückt werden, definiert.
Ähnlich wie bei PROVER 9 wird durch das angeben der Rolle der Verwendungszweck der Formel an VAMPIRE übergeben. Axiome und Hypothesen sind dabei die \textit{assumptions} und die Conjectures entsprechen den \textit{goals} aus PROVER 9.
Unterschiede in der Syntax sind selbstverständlich, da PROVER 9 nicht TPTP verwendet, obgleich es viele Übereinstimmungen gibt.
Auch der Punkt am Ende einer Zeile ist äquivalent. Unterschiedlich ist die Verwendung von Infix-Operatoren und deren vorherigen Definition als solche in PROVER 9, 
dies ist in VAMPIRE nicht möglich. In VAMPIRE ist es durch die $tff(\dots)$ jedoch möglich, explizit mit Variablen verschiedener Typen zu arbeiten.\cite{cav2013, prover9manual} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Benutzung von Vampire}
\label{sec:invocation}

Grundsätzlich ist die Benutzung von VAMPIRE wie in \cite{cav2013} gesagt, recht einfach. Nachdem man das Programm vorliegen hat, wird über die Kommandozeile die enthaltene ausführbare Datei gestartet. Nun liest VAMPIRE von \texttt{STDIN}. Der Benutzer kann direkt in der Kommandozeile eine TPTP-Formel eingegeben, die an VAMPIRE übergeben werden soll. Falls diese schon vorgeschrieben in einer Datei vorliegt, kann diese Datei über die jeweilige Shell-Syntax an VAMPIRE übergeben werden. Nachdem VAMPIRE das Problem erhalten hat, beginnt es direkt mit der Arbeit.\\
Unter Windows liefert die folgende Kommandozeile den Beweis für das in der input.txt geschriebene Problem und schreibt diesen, sonst in der Kommandozeile angezeigten Beweis, in die output.txt:\\


\texttt{vampire.exe < input.txt > output.txt}

\subsection{Kommandozeilenparameter}
\label{subsec:commands}
VAMPIRE lässt sich hochgradig in seiner Bearbeitung des Problems beeinflussen. Hierzu werden dem Aufruf in der Konsole Parameter beigefügt, von denen hier nur einige genannt werden.
\begin{itemize}
	\item \verb= --theory_axioms [on|off]= \label{arg:theoryaxiomsoff}\\
	Neben den Axiomen, die man der Problem-Datei hinzufügt, fügt VAMPIRE selbstständig bekannte 
	Axiome über bestimmte \emph{theories}, wie die Arithmetik auf natürlichen Zahlen, hinzu. 
	Dies kann mit diesem Parameter unterbunden werden.
	\item \verb=--proof [on|off]= \label{arg:proofoff}\\
	Möchte man die Gewissheit, dass das Problem bewiesen wurde, jedoch keinen Beweis ausgegeben haben, kann man diesen Parameter übergeben, um die Ausgabe zu unterbinden.

\item \verb|-t X| oder \verb|--time_limit X| \label{arg:timelimit}
Mit diesem Parameter und X als ganze Zahl bricht VAMPIRE nach X Sekunden den Versuch ab das Problem zu lösen, sollte bis dahin kein Beweis gefunden worden sein.
In diesem Fall gibt VAMPIRE \texttt{time limit expired} aus. Standardmäßig liegt das Zeitlimit bei 60  Sekunden.

\item \verb|-m X oder --memory_limit X| \label{arg:memorylimit}
Ähnlich wie bei dem Zeitlimit wird hier mit X als ganzzahliger Wert das Speicherlimit in Megabyte für VAMPIRE. Grundsätzlich nutzt Vampire allen verfügbaren Speicher, den es adressieren kann, was bei 32-bit Binaries weniger als 4GB entspricht.

\item \verb|--age_weight_ratio X:Y| \label{arg:ageweightratio}
Das Verhältnis von Alter zu Gewicht bestimmt, von welchen der beiden Prioritätsqueues, die VAMPIRE von Klauseln unterhält, wie viele gewählt werden. X und Y müssen ganzzahlige, positive Zahlen sein.
2:3 würde beispielsweise bedeuten, dass insgesamt 5 Klauseln gewählt werden, davon 2 der ältesten und 3 der leichtesten. 

\item \verb|--nongoal_weight_coefficient X| \label{arg:weightcoefficient}
Erlaubt das einstellen des Koeffizienten, der das Gewicht einer Klausel bestimmt. Normalerweise ist die Anzahl der Symbole in der Klausel gleichsam das Gewicht.

\item \verb|--max_weight X| \label{arg:maxweight}
Stellt das ansonsten von VAMPIRE veränderbare maximale Klauselgewicht ein. VAMPIRE kann bei Speicherknappheit oder bei nutzen der \emph{limited resource strategy} das Maximum ansonsten automatisch verringern um schwere Klauseln, zu verwerfen.

\item \verb|--forced_options <option1[:option2[:option3[...]]]>| \label{arg:forcedoptions}
Alle hier einzeln aufgeführten Optionen können mit einem Doppelpunkt hintereinander gereiht werden um mehrfache Optionen gemeinsam zu forcieren. 
\begin{itemize}
	\item \verb|propositional_to_bdd=off| \\
	Schaltet das Einführen von Prädikaten für BDD-Variablen aus.
	\item \verb|splitting=off| \\
	Schaltet das Einführen von Prädikaten für Entscheidungspunkte aus.
	\item \verb|equality_proxy=off|
	\item \verb|general_splitting=off|
	\item \verb|inequality_splitting=0|
	\item \verb|naming=0| \\
	Schaltet Einführen von Prädikaten zur Vermeidung von exponentiellem Ausdehnen während der Klausifizierung aus.
	Standardwert ist 8, je höher die Nummer, desto weniger eingeführte Namen.\\
\end{itemize}

\item \verb|--saturation_algorithm| \label{arg:saturationalgorithm}
\begin{itemize}
	\item \verb|lrs|\\
	Der standardmäßig gewählte Saturationsalgorithmus von VAMPIRE ist \emph{lrs} (\emph{limited resource strategy}).
	Dieser Algorithmus, der einzigartig in VAMPIRE sein soll, versucht unter den passiven und neuen Klauseln jene zu identifizieren, die niemals in der gegebenen Zeit gelöst werden können und verwirft diese. \cite{riazanov2003limited}
	\item \verb|discount|\\
	Diese Art des Algorithmus wurde ursprünglich im DISCOUNT System von Jürgen Avenhaus, Jörg Denzinger und Matthias Fuchs implementiert.
	Einen ähnlich arbeitenden Algorithmus verwenden neben VAMPIRE auch WALDMEISTER, E und SPASS. 
	Die passiven Klauseln, der erzeugten Klauselmenge nehmen nicht am Inferenz- oder Vereinfachungssystem teil. \cite{riazanov2003limited} 
	\item \verb|otter|\\
	Dieser Art des Algorithmus wurde ursprünglich im OTTER Theorembeweiser von William McCune implementiert.
	Einen ähnlich arbeitenden Algorithmus verwenden neben VAMPIRE auch GANDALF und SPASS. 
	Anders als beim vorherig genannten Algorithmus ist die Teilnahme der passiven Klauseln an der Vereinfachung möglich, wie zum Beispiel, bei Gleichheit der Einheiten, das Neuschreiben oder die Subsumtion. \cite{riazanov2003limited} 
\end{itemize}

\item \verb|-mode <mode>| \label{arg:modes}
Die Angabe eines Modus bestimmt den Ablauf des Beweisprozesses, 
indem die Verwendung einer bestimmten Strategie oder Strategiegemische vorgeben wird.
Einige mögliche Modi, die wie in ~\cite{hoder2011slides} beschrieben sind:
\begin{itemize}
	\item \verb|casc| \\
	Dieser auch bei dem gleichnamigen Wettbewerb verwendete Modus ist laut ~\cite{hoder2011slides} der beste der möglichen Modes.
	Das gegebene Problem wird im Vorfeld analysiert um die Charakteristiken zu erkennen, dann wird es einer von derzeit 43 Klassen zugewiesen. Jede Klasse besitzt eine Abfolge von Strategien, die das Problem lösen sollten.
	Der Mode scheint aber in der von uns verwendeten Version von Vampire nicht lauffähig zu sein (\texttt{sio is not a valid option}).
	\item \verb|casc_ltb| \\
	Dieser Mode wählt die Strategie äquivalent zum normalen casc-Mode. Der Input ist eine Batch-Datei nach den Vorgaben der CASC LTB (Large Theory Batch). Eine Besonderheit um Zeit zu sparen ist das nur einmalige einlesen der Axiome und das anschließende Hinzufügen dieser zu den Problemen denen sie zugewiesen sind. Dieser Mode ist multiprocessing-fähig und kann somit mehrere Strategien parallel verwendet. Dieser Mode wurde von uns nicht verwendet.
	\item \verb|axiom_selection| \\
	Sowohl Input als auch Output bei diesem Mode sind Formeln in TPTP oder CNF, wodurch er als Filter fungieren kann, da sein Output von zb. anderen Modes gelesen werden kann.
	Er vollzieht eine Sine-Axiom-Selection, wie in ~\cite{sinquanon} beschrieben.
	\item \verb|clausify| \\
	Dieser Mode konvertiert Formeln von TPTP nach CNF um und unterstützt dabei getypte Formeln, Arithmetik und auch Antwortliterale. Er erlaubt die Anwendung von etlichen Preprocessing rules die Vampire beinhaltet.
	\item \verb|grounding| \\
	Mit diesem Mode wird ein Einstein-Podolsky-Rosen-Paradoxon in ein aussagenlogisches Problem umgewandelt. Der Input erfolgt über TPTP, der Output ist im DIMACS CNF Format.
	Es wird splitting angewendet um die Anzahl der Variablen in den Klauseln und damit die der generierten aussagenlogischen Klauseln gering zu halten.
	\item \verb|consequence_elimination| \\
	Dieser Mode versucht aus einer gegebenen Menge an Behauptungen, der eine Theorie begründet liegen mag, eine der Behauptung aus den anderen herzuleiten.
	\item \verb|bpa| \\
	Bound Propagation (bpa) ersetzt hierbei für das Lösen von lineare Ungleichheiten (quantorenfreie lineare, reelle und rationale Arithmetik) das Superpositionscalculus.
	Dieser Mode ist in unserer Version nicht implementiert.
	\item \verb|program_analysis| \\
	Der letzte hier gezeigte Mode ist für die mit VAMPIRE mögliche Programmverifikation von C-Programmen. Hierbei muss die *.c-Datei an VAMPIRE übergeben werden.
	Dieser Mode wird in unserer Version nicht unterstützt.
\end{itemize}

\end{itemize} % Kommandozeilenoptionen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Segfaults}
%\label{subsec:segfaults}

%\begin{itemize}
%\item parentheses in input not aligned to magic waves in room
%\item it crash
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Funktionsweise}
\label{sec:mechanics}

Dieser Abschnitt gibt einen Einblick in die beweisrelevanten Abläufe, die durch einen typischen Aufruf von VAMPIRE ausgelöst werden, bis zur Ausgabe eines Ergebnisses.

\subsection{Preprocessing}
\label{subsec:preprocessing}

Nachdem VAMPIRE die Eingabe gelesen hat, finden vor der eigentlichen, oft zeitintensiven
Beweissuche einige vorbereitende Schritte statt.

\begin{enumerate}
	\itemsep0em 
	\item Wähle eine relevante Teilmenge von Formeln (optional).
	\item Füge die Axiome hinzu (optional).
	\item Bereinige die Formeln.
	\item Sollte eine Formel $\top$ oder $\bot$ beinhalten, \\vereinfache sie.
	\item Entferne if-then-else und let-in Verbindungen.
	\item Ebne die Formeln.
	\item Entferne reine Prädikate.
	\item Entferne nicht genutzte Prädikatdefinitionen \\(optional).
	\item Konvertiere die Formeln in equivalence negation normal form (ennf).
	\item Ersetze Subformeln durch ihre Namen.
	\item Konvertiere die Formeln in negation normal form (nnf) (optional).
	\item Skolemisiere die Formeln.
	\item Ersetze equality axioms.
	\item Lege eine Ordnung der Literale fest.
	\item Transformiere die Formeln in \\conjunctive normal form (cnf).
	\item Entferne die Funktionsdefinitionen (optional).
	\item Wende inequality splitting an (optional).
	\item Entferne Tautologien.
	\item Entferne reine Literale (optional).
	\item Entferne Klauseldefinitionen (optional).
\end{enumerate}

\subsection{Beweis durch Widerspruch}
\label{subsec:refutation}

Vampire beweist Theoreme durch Widerspruch.
Dazu wird die Negation der Hypothese $F$, zusammen mit den Axiomen,
der Formelmenge hinzugefügt.
Nun leitet Vampire durch Inferenz neue Formeln aus den Axiomen und $F$ her, 
mit dem Ziel, die leere Klausel $\bot$ (\texttt{\$false} in TPTP-Schreibweise) zu folgern.
Kann diese hergeleitet werden, ist die gesamte Formelmenge unerfüllbar.
Demzufolge hat die \textit{Negation} der Hypothese unter den angegebenen Axiomen keine Gültigkeit,
im Umkehrschluss ist die Hypothese $F$ bewiesen. \cite[S. 5]{cav2013}

Ist die Formelmenge hingegen erfüllbar, kann $\neg F$ aus den Axiomen bewiesen werden.
Damit ist $F$ widerlegt. \cite[S. 7]{cav2013}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inferenzsystem}
\label{subsec:inference}
TODO: Resolution and superposition inference system

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Saturation}
\label{subsec:saturation}


\begin{definition}{Saturierte Formelmenge}{def:saturatedset}
	Eine Formelmenge $S$ heißt saturiert unter einem Inferenzsystem $\mathds{I}$, wenn für jede $\mathds{I}$-Inferenz mit Prämissen in $S$ die Konklusion auch in $S$ ist.
\end{definition}

TODO: Saturation erklären

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Redundancy Elimination}
\label{subsec:redund}

TODO: Redundancy Elimination erklären

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Beweisausgabe}
\label{sec:output}

Während der Formelerzeugung bekommt jede Formel eine fortlaufende Nummer, beginnend mit den Axiomen und den Eingabeformeln. Wird ein Beweis gefunden, so gibt es einen gerichteten azyklischen Graphen (\emph{directed acyclic graph, DAG}) mit genau den Formeln als Knoten, welche zum Beweis (also dem Knoten \texttt{\$false}) hinführen. Die Kanten des DAG stellen Inferenz dar. Dieser DAG wird in der Beweisausgabe zeilenweise angezeigt. 
Am Beispiel dieser Zeile werden die einzelnen Bestandteile erklärt:\\ \\
\texttt{28. mult(inverse(X2),e) = X2 (2:6) [superposition 22,10]}
\begin{enumerate}
	\itemsep0em 
	\item Formelnummer: ~ \verb|28.|\\
	Die eindeutige Nummer, die jeder Formel zugewiesen wird
	\item Konklusion: ~ \verb|mult(inverse(X2),e) = X2|\\
	Die Konklusionsformel in TPTP-Syntax. Hier können automatisch erzeugte und abgeänderte
	Variablen- und Literalnamen auftauchen.
	\item ???: ~ \verb|(2:6)|\\
	Kein Plan wofür das steht.
	\item Resolutionsregel: ~ \verb|superposition|\\
	Die Regel, anhand derer diese Formel hergeleitet wurde.\\
	Formeln der Eingabe sind als \verb|[input]| deklariert.
	\item Prämissen: ~ \verb|22,10|\\
	In diesem Resolutionsschritt benutzte Formeln.
\end{enumerate}
In dieser Zeile ist also Formel 28 durch Superposition aus Formeln 22 und 10 hergeleitet worden.
Meist erzeugt Vampire viel mehr Formeln, die nicht zum Beweis führen und daher nicht zum Beweis-DAG gehören. Diese werden nicht ausgegeben.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visualisierung}
\label{subsec:outputvis}

TODO: Kurze Demo der Visualisationsmöglichkeit mit graphviz.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Schlusswort}
\label{sec:conclusion}
Write a small conclusion that summarizes what has been said ...?
Pointers to further reading...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography

% The bibliography entries are stored in "vampire.bib"
\bibliographystyle{unsrt}
\bibliography{vampire}

\end{document}

