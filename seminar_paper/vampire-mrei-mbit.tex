% Use the document class appropriate to your language and leave the other
% line commented out
\documentclass{acm_proc_article-sp-german}
%\documentclass{acm_proc_article-sp}

% These two lines help to keep enumerations and itemizations compact.
% Try commenting them out if you want to see the effect.
\usepackage{enumitem}
\setlist{nolistsep}

% The next two commands are for the code display example. Look into the
% documentation of the listings package for other configurations, in
% particular for a list of supported programming languages.
\usepackage{listings}
\lstset{language = C, 
        numbers=left, 
        numberstyle=\tiny,
        columns=fullflexible, 
        basicstyle=\sf, 
        xleftmargin = 0.5 cm}

% Display subfigures
\usepackage{subfig}

% Generate PDF hyperlinks when referencing sections and stuff. 
\usepackage{hyperref}

% Theorems like Definition and Proof
%\usepackage{amsthm}

% list bibliography by occurrence
\bibliographystyle{unsrt}

% Define Saturated sets
\newtheorem{satset}{Definition}

% This is the name of the folder you are placing your graphics files in.
% Defining it here makes LaTeX look for files there without you having
% to specify the folder again throughout the document.
\graphicspath{ {./graphics/} }

\begin{document}

\title{VAMPIRE: TODO: Titel}
\numberofauthors{2}
\author{
	\alignauthor
	Maximilian Reinhart\\
	\affaddr{mrei@informatik.uni-kiel.de}
	\alignauthor
	Martin Bittermann\\
	\affaddr{mbit@informatik.uni-kiel.de}
}

\date{\today}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
%Notes:
%Klaren Bezug auf [1] herausstellen.
%Grafiken nicht am Anfang des paper, eher am anfang von kapitel 2.
Dieser Artikel verschafft zunächst ein grundlegendes Verständnis über den automatischen Theorembeweiser VAMPIRE und
stellt den Bezug zu ~\cite{cav2013} her. \\
Es wird eine Einführung in die generelle Benutzung der Software und die verwendete Problembeschreibungssprache, TPTP, gegeben, 
die Funktionsweise und einige ausgewählte Algorithmen erklärt und
die Ausgabe von VAMPIRE sowohl analysiert als auch grafisch dargestellt.
Es werden Parallelen zu anderen Theorembeweisern aufgezeigt, VAMPIRE mit diesen Verglichen 
und zum Schluss wird mit Hinblick auf mögliche Anwendungsbereiche ein Fazit und ein Ausblick gegeben.
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Einleitung}
\label{sec:introduction}


Dieser Artikel bezieht sich primär auf ~\cite{cav2013} und versucht ebenso einen grundlegenden Überblick zu geben.
Dazu beziehen wir uns auf die Artikel ~\cite{hoder2010} und ~\cite{kovacs2009finding}.
(Überblick) 

(Struktur dieses Artikel mit Verweisen auf Kapitel)

Zuerst werden \hyperref[sec:foundations]{Grundlagen} über ATP vermittelt.\\
Dann \hyperref[sec:input]{TPTP Eingabe}.\\
Danach wird in \hyperref[sec:invocation]{Benutzung von Vampire}.\\
Anschließend \hyperref[sec:mechanics]{Funktionsweise}.\\
Schließlich \hyperref[sec:output]{Beweisausgabe} erklärt.\\
Schlussendlich \hyperref[sec:conclusion]{Fazit}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grundlagen}
\label{sec:foundations}
Automatische Theorembeweiser (ATP) versuchen eigenständig Aussagen über gegebene Formeln durch Anwendung von Regeln und Axiomen, die ihnen vorliegen, zu beweisen.
Hierfür wird das Problem von Hand in eine formale Struktur gebracht, die der Beweiser verarbeiten kann und diesem dann zur Bearbeitung übergeben.
Diese Formalisierung ist auch für triviale Probleme nicht gleichermaßen einfach und ist daher eine gefährliche Fehlerquelle. 
Nichtsdestotrotz ist für komplexe Probleme das Formalisieren einfacher als das Beweisen per Hand und nach korrekter Formalisierung liefert der ATP, 
sofern er einen Beweis findet, einen, wovon auszugehen ist, richtigen Beweis. 
Anwendung finden solche Beweiser in vielerlei Gebieten, wie zum Beispiel Software- und Hardware-Verifikation, Hardware Design und Systemen mit Wissenssammlungen.

VAMPIRE ist ein ATP für Logik erster Stufe, der erstmals 1993 implementiert wurde und im Verlauf mehrere Male um- und neugeschrieben wurde.
Der etwa 152,000 SLOC und wurde hauptsächlich von Andrei Voronkov und Kry{\v{s}}tof Hoder vollständig in C++ geschrieben, 
wobei neuere Entwicklungen und Ideen vermehrt von Laura Kov{\'a}cs stammen und Ioan Dragan die Arbeiten am SAT-Beweiser und der bound propagation übernommen hat.
Derzeitig wird an der vierten Version von VAMPIRE gearbeitet.

VAMPIRE hat dreißig Preise gewonnen und seit 1999 in der Weltmeisterschaft für automatische Theorembeweiser (CASC) jedes Mal mindestens in einer Kategorie gewonnen.
Insgesamt zwölf Mal hat er bei der CASC die Kategorie für Logik erster Stufe gewonnen und elf Mal für CNF/MIX. ~\cite{vampirehp} \\ Daher gilt VAMPIRE allgemein hin als sehr schnell.
Dank seiner Multiplattform- und Multicore-Unterstützung soll er auf allen gängigen Betriebssystemen, wie Linux, Windows und Mac eingesetzt werden können und mehrere Beweisversuche gleichzeitig bearbeiten können.
Wir vermögen zu bestätigen, dass die uns vorliegende Version auf Windows 7, 64-bit funktioniert, lediglich mehrere Kerne wurden nicht benutzt und somit nicht mehrere Beweisversuche parallel unternommen.
Vampire löst Probleme über die ihm über die Kommandozeile mitgegebene Strategie, die über den Mode-Befehl eingestellt werden kann und besitzt eine auf einzigartige limited resource strategy, die für kurze Zeitlimits sehr effizient sein soll. Mit Vampire ist es, neben seiner Funktion als ATP, auch möglich ein Expertensystem zu betreiben, das auf Grund von gegebenen Aussagen Antworten aus einer Wissenssammlung geben kann, ebenso ist VAMPIRE zur Programmverifikation für C-Programme mit Schleifen geeignet. 
Leider steht Vampire entgegen der Aussage in ~\cite{cav2013} nicht unter einer liberalen Lizenz, sondern unter einer nicht-freien, proprietären Lizenz, wie in ~\cite{vampirehp} einzusehen. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TPTP Eingabe}
\label{sec:input}

TPTP ist die Sprache in der Probleme geschrieben sein müssen, damit Vampire sie bearbeiten kann. Sie wird ebenfalls in der Thousands of Problems for Theorem Provers (TPTP) Bibliothek benutzt.
In ihr unterstützte Formeltypen sind unteranderem 
\begin{itemize}
	\item first order formula (FOF)
	\item typed first order formula (TFF)
	\item clause normal form (CNF)
	\item TPTP Process Instruction Language  (TPI)
	\item typed higher order form (THF)
\end{itemize}
von denen die wichtigsten, die VAMPIRE zudem unterstützt, FOF, TFF und CNF sind.

Die Syntax von TPTP ist wie folgt definiert:

\begin{tabular}{|c|c|}
	\hline TPTP & Bedeutung \\ 
	\hline ?[X] & $\exists$X \\
	\hline ![X] & $\forall$X \\
	\hline = & = \\
	\hline != & $\neq$ \\
	\hline $\sim$ & $\lnot$ \\
	\hline / & $\lor$ \\
	\hline \& & $\land$ \\
	\hline => & $\Rightarrow$ \\
	\hline <=> & $\leftrightarrow$ \\
	\hline Y & Variable \\
	\hline y & Literal \\
	\hline f(x, A, B) & Prädikat \\
	\hline \% \dots & Kommentar \\
	\hline
\end{tabular} 


Eine Formel in TPTP beginnt stets mit der Information über ihre Syntax. Hierbei können zum Beispiel $fof(\dots)$, $tff(\dots)$, $cnf(\dots)$ und einige mehr verwendet werden.
Innerhalb der Klammern werden drei Bereiche unterschieden, die jeweils mit einem Komma voneinander getrennt sind. 
Zuerst kommt der Name der Formel, welcher lediglich zur besseren Übersicht im späteren Beweis verwendet wird und ansonsten weder benutzt noch eindeutig sein muss,
dann die Rolle, die diese Formel einnimmt, hierbei kann es sich zum Beispiel um ein Axiom (axiom), eine Hypothese (hypothesis) oder auch eine Behauptung (conjecture) handeln.
Eine Rolle ist eine wichtige Voraussetzung für den Beweiser, denn hierdurch erfährt er, welche Grundvoraussetzungen und Annahmen getroffen wurden, die er als richtig behandeln kann um die gestellte Behauptung zu beweisen.
Letztendlich steht die Formel in der Anfangs gewählten Syntax, die der Beweiser behandeln kann.


Ein Beispiel für eine Formel in TPTP:\\
$fof(sum, axiom, ( ! [X,A] :( member(X,sum(A)) <=> ? [Y] : ( member(Y,A)  \&  member(X,Y))))).$

Über den Befehl $include(\dots)$ können Dateien, wie zum Beispiel eine Datei mit vorgefertigten Axiomen, während des Einlesens in Vampire zusätzlich importiert werden.

\subsection{Syntax}
\label{subsec:syntax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vergleich}
\label{subsec:tptpcomp}
Vergleich zu anderen Problembeschreibungssprachen.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Benutzung von Vampire}
\label{sec:invocation}

Wichtige Informationen zur Benutzung in ~\cite{hoder2011slides}.

Hinzugefügt auch: ~\cite{kovacs2011slides} und ~\cite{hodervoronkov2012slides}, wobei dies nur Slides sind, die aber wichtige Informationen haben. Quelle hat Link ist aber unsichtbar im Literaturverzeichnis.

\subsection{Modes}
\label{subsec:modes}

Modes bestimmen den Ablauf des Beweisprozesses indem eine spezielle Strategie oder Strategiegemische verwendet werden. 
Dieser Befehl beginnt mit \glqq --modes \grqq gefolgt von einem definierenden Schlüsselwort, welches den Mode bestimmt.
Einige mögliche Modes wie in ~\cite{hoder2011slides} beschrieben sind:
\begin{itemize}
\item casc \\
		Dieser auch bei dem gleichnamigen Wettbewerb verwendete Mode ist laut ~\cite{hoder2011slides}  der beste der möglichen Modes.
		Das gegebene Problem wird im Vorfeld analysiert um die Charakteristiken zu erkennen, dann wird es einer von derzeit 43 Klassen zugewiesen. Jede Klasse besitzt eine Abfolge von Strategien, die das Problem lösen sollten.
		Der Mode scheint aber in der von uns verwendeten Version von Vampire nicht lauffähig zu sein.\\
\item casc\_ltb \\
		Dieser Mode wählt die Strategie äquivalent zum normalen casc-Mode. Der Input ist eine Batch-Datei nach den Vorgaben der CASC LTB (Large Theory Batch). Eine Besonderheit um Zeit zu sparen ist das nur einmalige einlesen der Axiome und das anschließende Hinzufügen dieser zu den Problemen denen sie zugewiesen sind. Dieser Mode ist multiprocessing-fähig und kann somit mehrere Strategien parallel verwendet.
		Der Mode scheint aber in der von uns verwendeten Version von Vampire nicht lauffähig zu sein.\\
\item axiom\_selection \\
		Sowohl Input als auch Output bei diesem Mode sind Formeln in TPTP oder CNF, wodurch er als Filter fungieren kann, da sein Output von zb. anderen Modes gelesen werden kann.
		Er vollzieht eine Sine-Axiom-Selection, wie in ~\cite{sinquanon} beschrieben.\\
\item clausify \\
		Dieser Mode konvertiert Formeln von TPTP nach CNF um und unterstützt dabei getypte Formeln, Arithmetik und auch Antwortliterale. Er erlaubt die Anwendung von etlichen Preprocessing rules die Vampire beinhaltet. \\
\item grounding \\
		Mit diesem Mode wird ein Einstein-Podolsky-Rosen-Paradoxon in ein aussagenlogisches Problem umgewandelt. Der Input erfolgt über TPTP, der Output ist im DIMACS CNF Format.
		Es wird splitting angewendet um die Anzahl der Variablen in den Klauseln und damit die der generierten aussagenlogischen Klauseln gering zu halten. \\
\item consequence\_elemination \\
		Der letzte hier gezeigte Mode versucht aus einer gegebenen Menge an Behauptungen, der eine Theorie begründet liegen mag, eine der Behauptung aus den anderen herzuleiten.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Segfaults}
\label{subsec:segfaults}

\begin{itemize}
\item parentheses in input not aligned to magic waves in room
\item it crash
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Funktionsweise}
\label{sec:mechanics}
So funktionsierts.

\subsection{Preprocessing}
\label{subsec:preprocessing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beweisverfahren}
\label{subsec:proofmech}

\begin{satset}
	Saturated set of S: Contains S, no more formulas can be inferred under the inference system.\\
	TODO: More math symbols!
\end{satset}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ausgewählte Algorithmen im Detail}
\label{subsec:algos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Beweisausgabe}
\label{sec:output}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Erklärung}
\label{subsec:outputexplained}

\begin{itemize}
\item Formelnummer
\item Formel
\item ???
\item Regel
\item Benutzte Formeln

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visualisierung}
\label{subsec:outputvis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fazit}
\label{sec:conclusion}
Write a small conclusion that summarizes what has been said ...?
Open research areas...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography

% The bibliography entries are stored in "myrefs.bib"
\bibliographystyle{abbrv}
\bibliography{myrefs}

\end{document}

